[{"title":"CF2111 总结","url":"/CF2111-%E6%80%BB%E7%BB%93/","content":"\n\n\nCF2111 总结\nA\n翻译\n题解\n\n\nB\n翻译\n题解\n\n\nC\n翻译\n题解\n\n\nD\n翻译\n题解\n\n\nE\n翻译\n题解\n\n\nF\n翻译\n题解\n\n\nG\n翻译\n题解\n\n\n\n\n\n\n\n\n\nCF2111 总结A翻译有三个能量水晶，标号为 ，每个能量水晶有一个充能值 。一次操作可以让任意水晶的充能值上升任意正整数，但必须满足 。现要让每一个水晶的充能值均变为恰好给定正整数 ，问最少需要的操作次数。 组数据。\n题解观察到限制等价于 。容易发现  具有对称性，不妨设 ，容易发现通过三次操作可以让这三个充能值都变为 。（先让  变为 ，再对  重复）因此，若要让每个水晶的充能值都变为 ，最少需要的操作次数 。因此直接贪心模拟每次操作即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;void solve(int x) {\tint a[3] = {0, 0, 0}, opt = 0 ;\twhile(!((a[0] == x) &amp;&amp; (a[1] == x) &amp;&amp; (a[2] == x))) {\t\tint mnp=0; f(i,1,2) if(a[i] &lt; a[mnp]) mnp = i;\t\tint secmx=0x3f3f3f3f; f(i,0,2) if((i != mnp) &amp;&amp; (a[i] &lt; secmx)) secmx = a[i];\t\ta[mnp] = min(x, secmx * 2 + 1); ++opt;\t}\tcout &lt;&lt; opt &lt;&lt; '\\n';}int main() {\tint t=rd(); while(t--) {\t\tsolve(rd());\t}\treturn 0;}// 0 0 0// 1 0 0// max ai / 2 &lt;= min ai\n\nB翻译给定  个  的长方体，判断是否能将以前  个  数作为棱长的正方体箱子放入该长方体内，正方体的每条棱都与一条长方体的棱平行，且正方体不能悬空。 组数据。。其中  数满足 。\n\n题解容易发现若能将最大的两个箱子放入，不妨假设第一个箱子紧贴长方体下底面右后角放置，第二个箱子紧贴长方体右后角且放置在第一个箱子上，则第三个箱子必能放入第二个箱子左边，第一个箱子上面的位置（这是由于 ），以此类推，若能将最大的两个箱子放入，则必能将全部箱子放入。旋转  分别判断即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int f[11];bool fit(int x, int y, int z, int t) {\treturn (x &gt;= f[t]) &amp;&amp; (y &gt;= f[t]) &amp;&amp; (z &gt;= f[t] + f[t-1]) ;}bool test(int x, int y, int z, int t) {\treturn fit(x, y, z, t) | fit(x, z, y, t) | fit(y, x, z, t) | fit(y, z, x, t) | fit(z, x, y, t) | fit(z, y, x, t);}int main() {\tf[1] = 1; f[2] = 2; f(i,3,10) f[i] = f[i-1] + f[i-2];\tint t = rd(); while(t--) {\t\tint n = rd(), m = rd();\t\tf(i,1,m) {\t\t\tint w = rd(), l = rd(), h = rd();\t\t\tcout &lt;&lt; test(w, l, h, n);\t\t}\t\tcout &lt;&lt; '\\n';\t}\treturn 0;}\n\nC翻译给定  与数组 。一次操作可以选择任一位置 ，选择一项：\n\n对于所有 ，令 ，代价为 。\n\n对于所有 ，令 ，代价为 。\n\n\n要让  的值变为全部相同，求最小的代价。 组数据。。\n题解考察最后 ，容易发现最后的代价最小值为 操作涉及的数的数量的总和的最小值（下简称总次数）。考察  在原数列中的所有出现。容易发现对于一个全为  的连续段，我们可以在首尾分别操作，节省出等同于连续段长的总次数。容易发现这就是最小代价（注意到最优解中一个数一定不会被操作复数次，因此节省的操作一定是原本是  的数贡献的，而若一个  未被操作，意味着其前面的  没有执行向后的操作，其后面的  没有执行向前的操作，若两个贡献节省的操作的  中间有非  的数，则这个数一定不会被操作，矛盾）。直接验证即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int a[500005]; vector&lt;int&gt; pos[500005];int main() {\tint t = rd(); while(t--) {\t\tint n = rd(); f(i,1,n) rd(a[i]), pos[a[i]].pb(i);\t\tll mc = (1LL&lt;&lt;60LL);\t\tf(i,1,n) {\t\t\tll mnc = (1LL&lt;&lt;60LL), len = pos[i].size();\t\t\tif(pos[i].size()) {\t\t\t\tif(pos[i].size() == 1) mnc = 1LL * (n-1) * i;\t\t\t\telse {\t\t\t\t\tfor(int x = 0, y; x &lt; len; x = y + 1) {\t\t\t\t\t\ty = x; while((y+1 &lt; len) &amp;&amp; (pos[i][y+1] == pos[i][y] + 1)) ++y;\t\t\t\t\t\tmnc = min(mnc, 1LL * (n - (y-x+1)) * i) ;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tmc = min(mc, mnc);\t\t\tpos[i].clear();\t\t}\t\tcout &lt;&lt; mc &lt;&lt; '\\n';\t}\treturn 0;}\n\nD翻译有  个小组要上  节课，，每个小组的第  节课都不能占据相同的教室。有  个教室，每个教室由楼层和门牌号组成，具体来说，第  个门牌号是一个数 ，而其所在的楼层  满足 ，一个教室的索引值 ，保证每个教室的  不同，且 。若某小组相邻的两节课所在的教室楼层不同，则会付出等同于这两个楼层差的绝对值的代价。请你为这  个小组规划教室，最大化代价。 组数据。。\n题解容易发现对于任意一个小组，其上课的楼层按顺序一定是 ，因此问题被我们简化为了只有两节课的情况。\n将楼层排序，不妨设 ，设第  个小组第一节课在  教室，第二节课在  教室。总代价即为 。\n容易发现，如果某个 ，则我们一定尽量将其往前。反之则将其往后。对于  也同理。因此， 与  均为靠头尾的两段连续段且长度有关联。不妨  的头部长度为 ，尾部长度为 ，易知  的头部长度为 ，尾部长度为 。则代价即为 ，易知  时代价取最大值。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int n, m, a[100005];int main() {\tint t = rd(); while(t--) {\t\tn = rd(); m = rd(); f(i,1,m) a[i] = rd() ;\t\tsort(a+1, a+m+1) ;\t\tint ans = 0; int o = (n&amp;1), tn = n - o;\t\tf(i,1,(tn&gt;&gt;1)) {\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[m-i+1]) : (a[i]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[i]) : (a[m-i+1]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t}\t\tif(o) {\t\t\tint i = (tn&gt;&gt;1) + 1;\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[m-i+1]) : (a[i]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t}\t\tcerr &lt;&lt; ans &lt;&lt; '\\n';\t}\treturn 0;}// n group// m classroom// 1 group ~ 6 class\n\nE翻译给定一个长度为 ，由  组成的字符串，有  次操作，每次操作给定两个字符 ，代表可以将字符串中的一个字符  改为 。现在按顺序依次执行这  次操作（每次操作也可以选择不执行），最小化操作完成后字符串的字段序。 组数据。。\n题解考虑对于每个位置上的字符的操作，仅有可能为以下几种：\n\nP: \nQ: \nR: \nS: \nT: \n\n容易发现我们只需要贪心的，从前往后对于每个位置尽可能最小化该位置的最终字符，即可得到最小字典序。问题出在 P, T 操作之间对于  操作的争抢。我们可能会考虑到，如果对于某个位置 A 实施了 T 操作，会不会导致  减少（而如果换成 S 操作则不会减少），从而使得后面的位置 B 无法利用 P 操作了呢？事实上这是无需担忧的，我们不妨考虑这种矛盾出现的情况，用 S 操作替换 T 操作的前提是我们可以先在 A 位置实施 S 操作，再在 B 位置实施 P 操作，这就意味着我们有 , , ,  操作各一个，我们完全可以在 A 位置实施 T 操作而在 B 位置实施 Q 操作，一定不劣。\n因此，对于每个位置，我们贪心的优先按照 Q &gt; P, T &gt; S &gt; R 的顺序尽可能执行操作即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;string str; int n, q;set&lt;int&gt; B, D; vector&lt;int&gt; A, C; int posA, posC, bdC, bdA;void _try(int pos) {\tif(str[pos] == 'a') return ;\tif(str[pos] == 'b') {\t\tif(B.size()) B.erase(B.begin()), str[pos] = 'a';\t\telse if(posA &lt; bdA) {\t\t\tauto it = D.lower_bound(A[posA]);\t\t\tif(it != D.end()) ++posA, D.erase(it), str[pos] = 'a';\t\t}\t}\tif(str[pos] == 'c') {\t\tif(D.size()) D.erase(D.begin()), str[pos] = 'a';\t\telse if(posC &lt; bdC){\t\t\tauto it = B.lower_bound(C[posC]);\t\t\tif(it != B.end()) ++posC, B.erase(it), str[pos] = 'a';\t\t}\t\tif(str[pos] == 'c' &amp;&amp; posC &lt; bdC) --bdC, str[pos] = 'b';\t}}void solve() {\tcin &gt;&gt; n &gt;&gt; q &gt;&gt; str;\tf(i,1,q) {\t\tchar x, y; cin &gt;&gt; x &gt;&gt; y;\t\tif(x == 'b' &amp;&amp; y == 'c') A.pb(i), ++bdA;\t\tif(x == 'b' &amp;&amp; y == 'a') B.insert(i);\t\tif(x == 'c' &amp;&amp; y == 'b') C.pb(i), ++bdC;\t\tif(x == 'c' &amp;&amp; y == 'a') D.insert(i);\t}\tf(i,0,n-1) _try(i);\tcout &lt;&lt; str &lt;&lt; '\\n' ;\tposA = posC = bdC = bdA = 0; A.clear(); C.clear(); B.clear(); D.clear();}int main() {\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\tint t; cin &gt;&gt; t; while(t--) solve();\treturn 0;}/*operationA:(b, c) B(b, a) C(c, b) D(c, a)b-&gt;a: B, ADc-&gt;b: Cc-&gt;a: D, CB*/\n\nF翻译给定一张网格纸，构造一个四连通块，使得其周长与面积的比值等于 ，无解输出 。 组数据。任一构造使用的连通块面积不得超过 。\n\n题解不妨设现有一个连通块面积为 ，周长为 。若新增一个方格，则  增加 ，而  增加  或 。初始状态下，。\n设  增加  的次数为 , 增加  的次数为 ，则所有可能的  均应能写成  的形式。不难发现，若 ，则必有 ，若 ，则必有 。对应的构造是容易的。至此， 的问题已经处理完成。\n接下来考虑  的情况。容易发现我们只需要解如下不定方程组：\n\n容易发现该方程组一定有满足题目要求的解。简单枚举  即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;void solve() {\tint p = rd(), s = rd();\tif(p &gt;= 2 * s) {\t\tint res = p - 2*s;\t\tif(res == 0) { cout &lt;&lt; \"4\\n0 0\\n0 1\\n1 0\\n1 1\\n\" ; return ; }\t\tif((2*s) % res != 0) { cout &lt;&lt; \"-1\" &lt;&lt; '\\n'; return ; }\t\tint x = (2*s) / res;\t\tcout &lt;&lt; x &lt;&lt; '\\n' ;\t\tf(i,1,x) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n' ;\t} else {\t\tif(p%2) p*=2, s*=2 ;\t\tfor(int k = 1; ; ++k) {\t\t\tint Rp = p * k, Rs = s * k, v = (Rp - 4) / 2, a = v/2, b = v-(v/2);\t\t\tif((Rs &lt;= (a+1) * (b+1)) &amp;&amp; (Rs &gt;= a + b + 1)) {\t\t\t\tcout &lt;&lt; Rs &lt;&lt; '\\n' ;\t\t\t\tint x = Rs - (a + b + 1) ;\t\t\t\tf(i,1,a+1) f(j,1,b+1) {\t\t\t\t\tif((i == 1) || (j == 1)) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n' ;\t\t\t\t\telse if(x) { --x; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n'; }\t\t\t\t}\t\t\t\treturn ;\t\t\t}\t\t}\t}}int main() {\tint t=rd(); while(t--) solve();\treturn 0;}\n\nG翻译对于一个长度为  的序列，定义它是好的当且仅当它能被划分为前后两段，且前段中的所有数均大于后段中的所有数，或者后段中的所有数均大于前段中的所有数。\n给定一个长度为  的排列 ， 次询问该排列中  之间的子段是否是好的。强制在线。（采用交互实现，具体参照原题）\n题解考虑若一个子段  是好的，必然存在一个 ，使得可以将这一子段划分为前后两段，且满足以下两个条件之一：\n\n前段的所有数均不大于 ，后段的所有数均大于 。\n\n前段的所有数均不小于 ，后段的所有数均小于 。\n\n\n考虑逐渐令  增大来回答每个询问。记 。维护  的所有连续 01 段。容易发现这些 01 段只会发生  次变化，易于使用 std::set&lt; tuple&lt;int, int, int&gt; &gt; 维护。考虑相邻的两个连续 01 段，假设第一个连续段覆盖 ，第二个连续段覆盖 ，则对于所有  的 ，这些字段都是好的。\n预处理出所有这样的三元组 ，易知这些三元组的数量是  的。对于每个三元组按照  使用主席树维护即可。具体来说，每个  在  处令  增加 1，在  处撤销这一修改。使用差分优化即可避免区间修改。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 32e5 + 5, __ = 32e5 + 5;int n, p[_], pos[_], q, x[_];set&lt; tuple&lt;int, int, int&gt; &gt; blocks ;// x[i] = (p[i] &lt;= t) ? 1 : 0;// (r, l, v) i in [l, r], x[i] = vset&lt; tuple&lt;int, int, int&gt; &gt; tmp_ok;tuple&lt;int, int, int&gt; ok[__]; int tot;void updL(set&lt; tuple&lt;int, int, int&gt; &gt; :: iterator it) {\tauto itL = it; --itL;\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*itL); tie(r2, l2, v2) = (*it);\tassert(l2 == r + 1);\ttmp_ok.insert(make_tuple(l, r, r2)) ;\t// (l, m, r)\t// [L, R] is ok when l &lt;= L &lt;= m &lt; r &lt;= r2}void updR(set&lt; tuple&lt;int, int, int&gt; &gt; :: iterator it) {\tauto itR = it; ++itR;\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*it); tie(r2, l2, v2) = (*itR);\tassert(l2 == r + 1);\ttmp_ok.insert(make_tuple(l, r, r2)) ;\t// (l, m, r)\t// [L, R] is ok when l &lt;= L &lt;= m &lt; r &lt;= r2}void upd(int r) {\tauto it = blocks.lower_bound(make_tuple(r, 0, 0)) ;\tif(it != blocks.begin()) updL(it);\tif(it != --blocks.end()) updR(it);}void alter(int p) {\tx[p] = 1; // cerr &lt;&lt; \"Handle : \" &lt;&lt; p &lt;&lt; endl;\tif(p==1) {\t\tif(x[p+1] == 1) {\t\t\tblocks.erase(blocks.begin()) ;\t\t\tauto it = blocks.begin(); int l, r, v; tie(r, l, v) = (*it); assert(v == 1);\t\t\tblocks.erase(it); blocks.insert(make_tuple(r, l-1, v)) ; upd(r);\t\t} else {\t\t\tauto it = blocks.begin(); int l, r, v; tie(r, l, v) = (*it); assert(v == 0);\t\t\tblocks.erase(blocks.begin()) ;\t\t\tblocks.insert(make_tuple(1, 1, 1)) ; blocks.insert(make_tuple(r, l+1, v)) ;\t\t\tupd(1); upd(r);\t\t}\t\treturn ;\t}\tif(p==n) {\t\tif(x[p-1] == 1) {\t\t\tblocks.erase(--blocks.end()) ;\t\t\tauto it = --blocks.end(); int l, r, v; tie(r, l, v) = (*it); assert(v == 1);\t\t\tblocks.erase(it); blocks.insert(make_tuple(r+1, l, v)) ; upd(r+1);\t\t} else {\t\t\tauto it = --blocks.end(); int l, r, v; tie(r, l, v) = (*it); assert(v == 0);\t\t\tblocks.erase(it); blocks.insert(make_tuple(n, n, 1)); blocks.insert(make_tuple(r-1, l, v)) ;\t\t\tupd(n); upd(r-1);\t\t}\t\treturn ;\t}\tint Lv = x[p-1], Rv = x[p+1], t = (Lv&lt;&lt;1) + Rv;\tif(t==0) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); assert(it != blocks.end()); int l, r, v; tie(r, l, v) = (*it); /*cerr &lt;&lt; \"[\" &lt;&lt; l &lt;&lt; \", \" &lt;&lt; r &lt;&lt; \", \" &lt;&lt; v &lt;&lt; \"]\" &lt;&lt; endl;*/ assert(v == 0);\t\tblocks.erase(it); blocks.insert(make_tuple(p-1, l, 0)); blocks.insert(make_tuple(r, p+1, 0)); blocks.insert(make_tuple(p, p, 1));\t\tupd(p-1); upd(p); upd(r);\t}\tif(t==1) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); int l, r, v; tie(r, l, v) = (*it); assert(v == 0); assert(r == p);\t\tauto it2 = it; ++it2; int l2, r2, v2; tie(r2, l2, v2) = (*it2); assert(v2 == 1);\t\tblocks.erase(it); blocks.erase(it2); blocks.insert(make_tuple(r-1, l, 0)); blocks.insert(make_tuple(r2, l2-1, 1));\t\tupd(r-1); upd(r2);\t}\tif(t==2) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); int l, r, v; tie(r, l, v) = (*it); assert(v == 0); assert(l == p);\t\tauto it2 = it; --it2; int l2, r2, v2; tie(r2, l2, v2) = (*it2); assert(v2 == 1);\t\tblocks.erase(it); blocks.erase(it2); blocks.insert(make_tuple(r2+1, l2, 1)); blocks.insert(make_tuple(r, l+1, 0));\t\tupd(r2+1); upd(r);\t}\tif(t==3) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)), itL = it, itR = it; --itL; ++itR;\t\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*itL); tie(r2, l2, v2) = (*itR); assert(v2 == 1); assert(v2 == 1); assert(r == p-1); assert(l2 = p+1);\t\tblocks.erase(it); blocks.erase(itL); blocks.erase(itR); blocks.insert(make_tuple(r2, l, 1));\t\tupd(r2);\t}}int sum[__ * 20], rt[__ &lt;&lt; 1], ls[__ * 20], rs[__ * 20], tott;void pushup(int p) {\tsum[p] = sum[ls[p]] + sum[rs[p]] ;}void modify(int o, int&amp; p, int l, int r, int q, int x) {\tif(q&gt;r) {\t\tp=++tott; ls[p] = ls[o]; rs[p] = rs[o]; sum[p] = sum[o]; return ;\t}\tif(!p) p = ++tott, sum[p] = sum[o];\tif(l==r) { sum[p] = sum[p] + x; return ; }\tint mid=(l+r)&gt;&gt;1;\tif(q&lt;=mid) rs[p] = rs[o], modify(ls[o], ls[p], l, mid, q, x);\telse ls[p] = ls[o], modify(rs[o], rs[p], mid+1, r, q, x);\tpushup(p);}int query(int p, int l, int r, int ql, int qr) {\tif(l &gt; qr || r &lt; ql) return 0;\tif(ql &lt;= l &amp;&amp; r &lt;= qr) return sum[p];\tint mid = (l+r&gt;&gt;1), resL = 0, resR = 0;\tif(ql &lt;= mid) resL = query(ls[p], l, mid, ql, qr);\tif(qr &gt; mid) resR = query(rs[p], mid+1, r, ql, qr);\treturn resL + resR ;}pair&lt; pir, pir &gt; mods[__ &lt;&lt; 1] ; int totc, rtL[_];int main() {\trd(n); f(i,1,n) rd(p[i]), pos[p[i]] = i; blocks.insert(make_tuple(n, 1, 0)); f(i,1,n) alter(pos[i]);\tfor(auto v : tmp_ok) ok[++tot] = v;\tcerr &lt;&lt; tot &lt;&lt; endl;\tf(i,1,tot) {\t\tint l, m, r; tie(l, m, r) = ::ok[i];\t\tmods[++totc] = mp(mp(l, m+1), mp(r, 1));\t\tmods[++totc] = mp(mp(m+1, m+1), mp(r, -1));\t}\tf(i,1,n) mods[++totc] = mp(mp(i, 1), mp(n, 0));\tsort(mods+1, mods+totc+1);\tf(i,1,totc) {\t\tint tl=mods[i].fir.fir, l=mods[i].fir.sec, r=mods[i].sec.fir, x=mods[i].sec.sec;\t\tmodify(rt[2*i-2], rt[2*i-1], 1, n, l, x);\t\tmodify(rt[2*i-1], rt[2*i], 1, n, r+1, -x);\t}\tint p = 0;\tf(i,1,n) {\t\twhile(p+1 &lt;= totc &amp;&amp; mods[p+1].fir.fir &lt;= i) ++p;\t\trtL[i] = rt[2*p];\t}\trd(q); f(i,1,q) {\t\tint L = rd(), R = rd(), ok = 0;\t\t// f(x,1,tot) {\t\t\t// int l, m, r; tie(l, m, r) = ::ok[x];\t\t\t// [L, R] is ok when l &lt;= L &lt;= m &lt; R &lt;= r\t\t\t// if((l &lt;= L) &amp;&amp; (L &lt;= m) &amp;&amp; (m &lt; R) &amp;&amp; (R &lt;= r)) ok = 1;\t\t// }\t\tok = query(rtL[L], 1, n, 1, R);\t\t// cerr &lt;&lt; ok &lt;&lt; endl;\t\tcout &lt;&lt; ( (ok&gt;0) ? \"YES\" : \"NO\" ) &lt;&lt; '\\n';\t\tif(!(i%10)) cout.flush();\t}\t\treturn 0;}","categories":["CF 总结"],"tags":["数学","模拟","贪心","构造"]},{"title":"暑假日记","url":"/%E6%9A%91%E5%81%87%E6%97%A5%E8%AE%B0/","content":"\n\n\n暑期日记项目\n七月\n7.14\n早上\n下午\n晚上\n\n\n7.15\n早上\n下午\n晚上\n\n\n7.16\n早上\n下午\n晚上\n\n\n7.17\n早上\n下午\n晚上\n\n\n\n\n\n\n\n\n\n暑期日记项目时光在冗杂中飞逝，转瞬之间这个“人生中最长的暑假”已经行至正中。回望过去的一个半月，惊叹于自己所做事情至少，懊悔于自己之怠惰。\n是而建此项目，所望唯监督自己，所以能奋发图强，增益不能。\n所记或颇为琐碎，大抵流水账尔。然而所以记之者，不过待后观之而一笑尔。\n七月7.14早上\n搭建 github pages 与本地的 hexo 环境，更换 arknights 主题，搭建 Gitalk。发布暑假日记博客。\n\n拿日语书快递\n\n\n下午\n看视频\n\n睡觉\n\n\n晚上\n去了趟大士院吃了点南昌特色，然后在八一广场逛了一圈\n\n看视频\n\n\n话说感觉最近看视频有点多了，要不从明天开始每看一个视频就写一个总结&amp;观后感丢这里？\n明天开始更新一下每天的饭（？\n7.15早上\n早饭-6.5r\n\n\n早饭-6.5r\n\n\n\n写 CF2111 总结\n\n下午\n吃，玩，逛，集\n\n晚上\n集\n\n7.16早上\n集\n\n下午\n集\n\n晚上\n集\n\n7.17早上\n昨晚睡的很晚所以睡懒觉\n\n集\n\n\n下午\n集\n\n晚上\n集\n\n","categories":["暑假日记"],"tags":["记录","工程","生活","ACM"]},{"title":"错题本","url":"/%E9%94%99%E9%A2%98%E6%9C%AC/","content":"\n\n\nSTL 使用\n\n\n\n\n\nSTL 使用\n边往一个 vector 里加数边把 vector.size() 当定值用\n\n","categories":["错题本"]},{"title":"CF2122-总结","url":"/CF2122-%E6%80%BB%E7%BB%93/","content":"\n\n\nCF2122-总结\nA\n翻译\n题解\n\n\nB\n翻译\n题解\n\n\nC\n翻译\n题解\n\n\nD\n翻译\n题解\n\n\nE\n题意\n题解\n\n\nF\n题意\n题解\n\n\n\n\n\n\n\n\n\nCF2122-总结A翻译在一个  的每一个格子中包含一个非负数的网格中，称一条路径是 down/right 的，当且仅当这条路径从左上角格子开始，且其中的每一步要么向右一格，要么向下一格。称一条路径是 greedy 的，当且仅当这条路径满足以下条件：\n\n这条路径是 down/right 路径\n如果当前格子右边的数比下边的大，那么一定向右。如果当前格子下边的数比右边的大，那么一定向下。（若有一边没有格子或两侧相等，则无限制。）\n\n定义一条路径的权值是其经过的所有格子上的数的总和。对于给定的 ，求是否存在一个  的网格使得每条 greedy 的路径都不是权值最大的 down/right 路径。 组数据。\n题解容易发现  的网格， 的网格中 greedy 路径一定是权值最大的。这些情况下答案是 NO。\n对于  的网格，有以下构造。\n\n更大的情况是类似的。答案一定是 YES。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int main() {\tint t = rd(); while(t--) {\t\tint n = rd(), m = rd();\t\tcout &lt;&lt; ((((n &lt;= 2) &amp;&amp; (m &lt;= 2)) || (n == 1) || (m == 1)) ? (\"NO\") : (\"YES\")) &lt;&lt; endl;\t}\treturn 0;}\n\nB翻译给定  个 piles。第  个 pile 从上到下由  个 0 和  个 1 组成。一次操作是从某个 pile 的最上方取走一个数，将其插入任意一个 pile 的任意位置。\n\n给定 , 。欲通过若干次操作使得 ，第  堆石子都变为从上到下由  个 0 和  和 1 组成。求最少使用多少次操作。\n， 组数据，保证 。\n题解若某一个 pile 需要移走若干个 1，则这些 1 上面的 0 必须先全部被移走。若某一 pile 中  且 ，则我们必须先将这些 0 移走。样例提醒我们我们可以往本堆的下面放来把一些 1 暴露在最上面，这样可以把这些多余的 1 移给别的缺少的堆的。这样做需要  步。容易证明这样做步数是最少的。\n如果某一 pile 中  且 ，那么同理我们必须把这些 0 移走。不同的是，我们只将后  个石子移到本堆的下面。这样做也需要  步。容易证明这样做步数是最少的。同样，如果某一 pile 中 ，那么至少需要  步。\n发现每一个下界都能达到。直接统计即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;void solve() {\tint n = rd(); ll ans = 0;\tfor(int i = 1; i &lt;= n; ++i) {\t\tint a = rd(), b = rd(), c = rd(), d = rd();\t\tif(b &gt; d) ans += (a + b - d);\t\telse if(a &gt; c) ans += (a - c);\t}\tcout &lt;&lt; ans &lt;&lt; endl;}int main() {\tint t = rd(); while(t--) {\t\tsolve();\t}\treturn 0;}\n\nC翻译给定  个平面上的点 。选出  个点对（每个点不被重复选择），最大化这些点对间曼哈顿距离的和，输出方案。 组数据，保证 。\n题解考虑按  排序所有点。找一条线尽可能平分左右的点。发现左边的点一定不会和左边的点匹配，右边的点亦然。若否，则必可以在左右各找到一个内部匹配的点对，进行交换一定使答案增大。\n因此，左边的点一定和右边的某个点匹配。所以  坐标维度上，左边的点  一定贡献 ，右边的点  一定贡献 。因此我们可以不考虑  维度。\n不妨考虑  的情况。问题变成了给定两个数列  和 ，找一个配对方案最大化组内  与  差的绝对值。容易发现两两排序，让小的匹配大的即可（证明和上面的类似）。\n 的情况，点多的那边必然有一个点未被匹配。枚举未被匹配的点，其它点依然是按顺序匹配的。容易发现每个点最多和某两个另一侧的点匹配，且必定只有某个后缀是匹配前一个另一侧节点的。前缀和维护即可快速计算某个点未被匹配情况下的答案。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt; pair&lt;int, int&gt;, int &gt;#define fir first.first#define sec first.second#define thr second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 200005;pir P[_]; int n;int calc(pir x, pir y) {\treturn abs(x.fir - y.fir) + abs(x.sec - y.sec);}ll tans[_][2];void solve() {\trd(n); f(i,1,n) { rd(P[i].fir); rd(P[i].sec); P[i].thr = i; }\tsort(P+1, P+1+n) ;\tll ans = 0; int ansi = 0;\tif(!(n&amp;1)) { // all dots are chosen\t\tint p = n/2;\t\tsort(P+1, P+p+1, [](pir x, pir y){return x.sec &lt; y.sec;});\t\tsort(P+p+1, P+n+1, [](pir x, pir y){return x.sec &gt; y.sec;});\t\tf(i,1,p) ans += calc(P[i], P[p + i]);\t\tf(i,1,p) cout &lt;&lt; P[i].thr &lt;&lt; ' ' &lt;&lt; P[p + i].thr &lt;&lt; '\\n';\t\t// cerr &lt;&lt; \"Ans = \" &lt;&lt; ans &lt;&lt; endl;\t} else { // one dot is not chosen\t\tint p = n/2; //[1, p], [p+1, n]\t\tsort(P+1, P+p+1, [](pir x, pir y){return x.sec &lt; y.sec;});\t\tsort(P+p+1, P+n+1, [](pir x, pir y){return x.sec &gt; y.sec;});\t\tmemset(tans, 0, sizeof(tans));\t\tf(i,1,p+1) {\t\t\ttans[i][0] = calc(P[p + i], P[i]), tans[i][1] = calc(P[p + i], P[i-1]);\t\t\ttans[i][0] += tans[i-1][0]; tans[i][1] += tans[i-1][1];\t\t}\t\tf(i,1,p+1) {\t\t\tif(ans &lt; tans[i-1][0] + tans[p+1][1] - tans[i][1]) ans = tans[i-1][0] + tans[p+1][1] - tans[i][1], ansi = i ;\t\t}\t\tf(i,1,p+1) {\t\t\tif(i &lt; ansi) cout &lt;&lt; P[p + i].thr &lt;&lt; ' ' &lt;&lt; P[i].thr &lt;&lt; '\\n';\t\t\tif(i &gt; ansi) cout &lt;&lt; P[p + i].thr &lt;&lt; ' ' &lt;&lt; P[i-1].thr &lt;&lt; '\\n';\t\t}\t\t// cerr &lt;&lt; \"Ans = \" &lt;&lt; ans &lt;&lt; endl;\t}}int main() {\tint t = rd(); while(t--) {\t\tsolve();\t}\treturn 0;}\n\nD翻译给定一个  个点  条边的无向图。一个 token 第  秒时在 1 号节点。在第  秒时，如果 token 在  号节点上，则可以从以下两个操作中选择一个执行：\n\n在原地等待  秒。\n花费  时间通过  节点的第  条边。\n\n其中， 节点的第  条边指按照输入顺序，包含  节点的第  条边。求到达  号点的最小时间，以及最小化这一时间的前提下的最小等待时间。 组数据，保证 。\n题解猜测最小所需时间的最大值不会很多，因为如果一个节点的度数很小，那么无论往哪走等待时间都很小。如果一个节点的度数很大，那么虽然我们在这个节点可能要等很久，但是我们可以选择的节点数量也很多。可以证明所需时间的最小值是 量级的（用路径上节点  的总和作为所需时间的上界，参见这一结论）。那么枚举时间，更新可达性，把最小等待时间记录在每个节点上一起更新即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 5005, inf = 0x3f3f3f3f;int mwt[_], tmp[_], ok[_];vector&lt;int&gt; edge[_]; int n, m;void solve() {\tf(i,1,n) edge[i].clear(), ok[i] = 0, mwt[i] = inf;\tok[1] = 1; mwt[1] = 0; rd(n); rd(m); f(i,1,m) {\t\tint u = rd(), v = rd();\t\tedge[u].pb(v); edge[v].pb(u);\t}\tfor(int tim = 0; ;  ++tim) {\t\t// cerr &lt;&lt; \"at tim \" &lt;&lt; tim &lt;&lt; endl;\t\tvector&lt;int&gt; L;\t\tf(i,1,n) { if(ok[i]) L.pb(i); tmp[i] = inf; }\t\tfor(auto i : L) if(edge[i].size()) {\t\t\tint ver = edge[i][tim % edge[i].size()] ;\t\t\tok[ver] = 1;\t\t\ttmp[ver] = min(tmp[ver], mwt[i]);\t\t\t// cerr &lt;&lt; \"set ok \" &lt;&lt; edge[i][tim % edge[i].size()] &lt;&lt; endl;\t\t}\t\tf(i,1,n) mwt[i] = min(mwt[i] + 1, tmp[i]);\t\tif(ok[n]) { cout &lt;&lt; tim + 1 &lt;&lt; ' ' &lt;&lt; mwt[n] &lt;&lt; endl; break; }\t}}int main() {\tint t = rd(); while(t--) {\t\tsolve();\t}\treturn 0;}\n\nE题意在一个  的每一个格子中包含一个不大于  的正整数的网格中，称一条路径是 down/right 的，当且仅当这条路径从左上角格子开始，且其中的每一步要么向右一格，要么向下一格。称一条路径是 greedy 的，当且仅当这条路径满足以下条件：\n\n这条路径是 down/right 路径\n如果当前格子右边的数比下边的大，那么一定向右。如果当前格子下边的数比右边的大，那么一定向下。（若有一边没有格子或两侧相等，则无限制。）\n\n定义一条路径的权值是其经过的所有格子上的数的总和。给定一个  的网格，其中有一些位置没有数（用 -1 表示）。求有多少种方式填充满这一网格，且对于每个子矩形，必定有一条 greedy 的路径的权值是所有 down/right 的路径中权值最大的。\n题解以下称 对于每个子矩形，必定有一条 greedy 的路径的权值是所有 down/right 的路径中权值最大的 为限制 A。\n 的子矩形中限制 A 一定满足。不妨假设我们从某个  矩形的左上角开始走，如果下一步是向右走，我们就变成了另一个矩形，可以不作考虑。如果往下走，我们到任意一个第二行的点的 greedy 的路径是确定的，也就是先向下然后一直向右。这启发我们将所有限制在所有满足  的  处考虑。容易发现这样的  给出的限制是 。不妨移去第一行第一个数和最后一行最后一个数，容易证明它们不会影响限制（需要注意的是，如果移去了 -1，需要在最后的答案中乘上一个 ）。\n此时我们的限制变成了这样的形式：对于所有 ，如果 ，那么 ，也就是 。容易发现最靠后的限制永远是最紧的。因此只需要留存一个限制。\n进行动态规划的尝试。我们可以设计一个状态  储存现在的 ，当  增加到  时，我们只需要考虑新的  和 。如果 ，我们更新  即可。否则，我们直接让限制缩小 。因此，我们记  为如果  对当前的限制为 , 把  填满的合法方案数。已经可以完成转移，但还有初始无限制的情况不能直接使用 ，否则第二维会过大。因此再设  为  无限制，把  填满的方案数。 和  都确定的情况转移是容易的。否则直接枚举新的  和  并转移。最坏时间复杂度 。使用前缀和优化  和  都是 -1 的情况即可做到  复杂度，足以通过。可以优化到 。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 505, mod = 998244353;int a[2][_], n, k, ans;int modadd(int a, int b) {\treturn (a + b &gt; mod) ? (a + b - mod) : (a + b);}int modminu(int a, int b) {\treturn (a - b &lt; 0) ? (a - b + mod) : (a - b);}int f[_][_], g[_], s[_];void solve() {\trd(n); rd(k); n = n - 1; int tmp = 1;\tif(rd() == -1) tmp *= k; f(i,1,n) rd(a[0][i]);\tf(i,1,n) rd(a[1][i]); if(rd() == -1) tmp *= k;\tmemset(f, 0, sizeof(f)); memset(g, 0, sizeof(g));\tg[n+1] = 1; f(i,0,k) f[n+1][i] = 1;\td(i,1,n) {\t\tif((a[0][i] != -1) &amp;&amp; (a[1][i] != -1)) {\t\t\tint x = a[0][i], v = a[1][i];\t\t\tif(x &gt;= v) { f(j,x-v,k) f[i][j] = modadd(f[i][j], f[i+1][j - (x - v)]); g[i] = modadd(g[i], g[i+1]); }\t\t\tif(v &gt; x) { f(j,0,k) f[i][j] = modadd(f[i][j], f[i+1][v - x]); g[i] = modadd(g[i], f[i+1][v - x]); }\t\t}\t\tif((a[0][i] != -1) &amp;&amp; (a[1][i] == -1)) {\t\t\tint x = a[0][i] ;\t\t\tf(v,1,k) {\t\t\t\tif(x &gt;= v) { f(j,x-v,k) f[i][j] = modadd(f[i][j], f[i+1][j - (x - v)]); g[i] = modadd(g[i], g[i+1]); }\t\t\t\tif(v &gt; x) { f(j,0,k) f[i][j] = modadd(f[i][j], f[i+1][v - x]); g[i] = modadd(g[i], f[i+1][v - x]); }\t\t\t}\t\t}\t\tif((a[0][i] == -1) &amp;&amp; (a[1][i] != -1)) {\t\t\tint v = a[1][i] ;\t\t\tf(x,1,k) {\t\t\t\tif(x &gt;= v) { f(j,x-v,k) f[i][j] = modadd(f[i][j], f[i+1][j - (x - v)]); g[i] = modadd(g[i], g[i+1]); }\t\t\t\tif(v &gt; x) { f(j,0,k) f[i][j] = modadd(f[i][j], f[i+1][v - x]); g[i] = modadd(g[i], f[i+1][v - x]); }\t\t\t}\t\t}\t\tif((a[0][i] == -1) &amp;&amp; (a[1][i] == -1)) {\t\t\ts[0] = f[i+1][0]; f(j,1,k) s[j] = modadd(s[j-1], f[i+1][j]);\t\t\tf(v,1,k) {\t\t\t\tint bd = k - v;\t\t\t\tf(j,0,k) {\t\t\t\t\tf[i][j] = modadd(f[i][j], modminu(s[v-1], s[0])) ;\t\t\t\t\tif(j &lt;= bd) f[i][j] = modadd(f[i][j], s[j]);\t\t\t\t\tif(j &gt; bd) f[i][j] = modadd(f[i][j], modminu(s[j], s[j - bd - 1])) ;\t\t\t\t}\t\t\t\tf(x,1,k) {\t\t\t\t\tif(x &gt;= v) g[i] = modadd(g[i], g[i+1]);\t\t\t\t\tif(v &gt; x) g[i] = modadd(g[i], f[i+1][v - x]);\t\t\t\t}\t\t\t}\t\t}\t}\tans = g[1] ;\tcout &lt;&lt; 1LL * tmp * ans % mod &lt;&lt; endl;}int main() {\tint t = rd(); while(t--) solve();\treturn 0;}\n\nF题意给定  和  个正整数 。构造一个  个点的多边形，其三角剖分数量恰好是\n\n多边形可以按照顺时针方向或逆时针方向给出。各坐标必须是  间的整数。多边形的两条共点边可以共线。多边形不必是凸的。\n题解看到这个  第一眼想到的就是它就是 。因此想到组合数。考虑能否构造出三角剖分数量恰好是  的多边形。\n“很容易”想到在一边上放  个点，另一条边上放  个点，类似这样就可以构造出一个满足条件的多边形（例图来自官方题解）：\n\n\n如图是一个恰有  种三角剖分的多边形\n\n\n证明可以考虑下面最右的节点包含在哪个三角剖分内，然后列出递推式，发现等同于组合数。\n考虑如何合并多个这样的多边形。想到通过构造让三角剖分除这些多边形外的部分都是确定的，而这些多边形的部分互相独立。可以这样构造：\n\n\n注意到三角剖分中必然包含三角形 ANO，否则便会违背三角形不能有点以外的相交的限制\n\n\n因此，可以把若干个组合数形式的  用  个点合并。直接使用\n\n记 。这种方法使用的点的数量是  的。超出了限制范围。\n观察到\n\n 的构造是前面的内容。左右是两个规模更小的子问题。取 分治解决即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 10, __ = 334, inf = 1000000;int n, a[_], c[_], tot = 0, nowx = 0, x[__], y[__];void build(int l, int r) {\tif(l == r) return ;\tint mid = (l+r)&gt;&gt;1;\tint sl, sr = sl = 0;\tf(i,l,mid) sl += a[i]; f(i,mid+1,r) sr += a[i];\tf(i,0,sl) x[++tot] = nowx, y[tot] = i; ++nowx;\td(i,0,sr) x[++tot] = nowx, y[tot] = i; ++nowx;\tif(r == l + 1) return ;\tbuild(l, mid); build(mid+1, r);}int main() {\trd(n); f(i,1,n) rd(a[i]);\tbuild(1, n);\tcout &lt;&lt; tot + 1 &lt;&lt; endl;\tf(i,1,tot) cout &lt;&lt; x[i] &lt;&lt; ' ' &lt;&lt; y[i] &lt;&lt; '\\n' ;\tcout &lt;&lt; inf &lt;&lt; ' ' &lt;&lt; -1 &lt;&lt; endl;\treturn 0;}","categories":["CF 总结"],"tags":["数学","dp","图论","多边形"]},{"title":"常用(?)结论","url":"/%E5%B8%B8%E7%94%A8-%E7%BB%93%E8%AE%BA/","content":"\n\n\n图\n最短路\n\n\n\n\n\n\n\n图最短路\n边权均为  的无向图上，最短路上的节点的 deg 总和是  量级的\n\n\n证明\n\n考虑最短路上的不相邻的任意两个节点，这两个节点之间不可能有边。\n考虑最短路外的任意一个节点，如果它与四个最短路上的阶段均有连边，也会存在矛盾\n\n如图，红色路径一定比黑色路径短\n\n所以设  是最短路上的节点数量。我们有最短路上的所有节点的度数和不大于 ，是  量级的。\n"}]