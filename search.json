[{"title":"CF2111 总结","url":"/CF2111-%E6%80%BB%E7%BB%93/","content":"\n\n\nCF2111 总结\nA\n翻译\n题解\n\n\nB\n翻译\n题解\n\n\nC\n翻译\n题解\nD\n翻译\n题解\n\n\nE\n翻译\n题解\n\n\nF\n翻译\n题解\n\n\nG\n翻译\n题解\n\n\n\n\n\n\n\n\n\nCF2111 总结A翻译有三个能量水晶，标号为 ，每个能量水晶有一个充能值 。一次操作可以让任意水晶的充能值上升任意正整数，但必须满足 。现要让每一个水晶的充能值均变为恰好给定正整数 ，问最少需要的操作次数。 组数据。\n题解观察到限制等价于 。容易发现  具有对称性，不妨设 ，容易发现通过三次操作可以让这三个充能值都变为 。（先让  变为 ，再对  重复）因此，若要让每个水晶的充能值都变为 ，最少需要的操作次数 。因此直接贪心模拟每次操作即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;void solve(int x) {\tint a[3] = {0, 0, 0}, opt = 0 ;\twhile(!((a[0] == x) &amp;&amp; (a[1] == x) &amp;&amp; (a[2] == x))) {\t\tint mnp=0; f(i,1,2) if(a[i] &lt; a[mnp]) mnp = i;\t\tint secmx=0x3f3f3f3f; f(i,0,2) if((i != mnp) &amp;&amp; (a[i] &lt; secmx)) secmx = a[i];\t\ta[mnp] = min(x, secmx * 2 + 1); ++opt;\t}\tcout &lt;&lt; opt &lt;&lt; '\\n';}int main() {\tint t=rd(); while(t--) {\t\tsolve(rd());\t}\treturn 0;}// 0 0 0// 1 0 0// max ai / 2 &lt;= min ai\n\nB翻译给定  个  的长方体，判断是否能将以前  个  数作为棱长的正方体箱子放入该长方体内，正方体的每条棱都与一条长方体的棱平行，且正方体不能悬空。 组数据。。其中  数满足 。\n\n题解容易发现若能将最大的两个箱子放入，不妨假设第一个箱子紧贴长方体下底面右后角放置，第二个箱子紧贴长方体右后角且放置在第一个箱子上，则第三个箱子必能放入第二个箱子左边，第一个箱子上面的位置（这是由于 ），以此类推，若能将最大的两个箱子放入，则必能将全部箱子放入。旋转  分别判断即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int f[11];bool fit(int x, int y, int z, int t) {\treturn (x &gt;= f[t]) &amp;&amp; (y &gt;= f[t]) &amp;&amp; (z &gt;= f[t] + f[t-1]) ;}bool test(int x, int y, int z, int t) {\treturn fit(x, y, z, t) | fit(x, z, y, t) | fit(y, x, z, t) | fit(y, z, x, t) | fit(z, x, y, t) | fit(z, y, x, t);}int main() {\tf[1] = 1; f[2] = 2; f(i,3,10) f[i] = f[i-1] + f[i-2];\tint t = rd(); while(t--) {\t\tint n = rd(), m = rd();\t\tf(i,1,m) {\t\t\tint w = rd(), l = rd(), h = rd();\t\t\tcout &lt;&lt; test(w, l, h, n);\t\t}\t\tcout &lt;&lt; '\\n';\t}\treturn 0;}\n\nC翻译给定  与数组 。一次操作可以选择任一位置 ，选择一项：\n\n对于所有 ，令 ，代价为 。\n\n对于所有 ，令 ，代价为 。\n\n\n要让  的值变为全部相同，求最小的代价。 组数据。。\n题解考察最后 ，容易发现最后的代价最小值为 操作涉及的数的数量的总和的最小值（下简称总次数）。考察  在原数列中的所有出现。容易发现对于一个全为  的连续段，我们可以在首尾分别操作，节省出等同于连续段长的总次数。容易发现这就是最小代价（注意到最优解中一个数一定不会被操作复数次，因此节省的操作一定是原本是  的数贡献的，而若一个  未被操作，意味着其前面的  没有执行向后的操作，其后面的  没有执行向前的操作，若两个贡献节省的操作的  中间有非  的数，则这个数一定不会被操作，矛盾）。直接验证即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int a[500005]; vector&lt;int&gt; pos[500005];int main() {\tint t = rd(); while(t--) {\t\tint n = rd(); f(i,1,n) rd(a[i]), pos[a[i]].pb(i);\t\tll mc = (1LL&lt;&lt;60LL);\t\tf(i,1,n) {\t\t\tll mnc = (1LL&lt;&lt;60LL), len = pos[i].size();\t\t\tif(pos[i].size()) {\t\t\t\tif(pos[i].size() == 1) mnc = 1LL * (n-1) * i;\t\t\t\telse {\t\t\t\t\tfor(int x = 0, y; x &lt; len; x = y + 1) {\t\t\t\t\t\ty = x; while((y+1 &lt; len) &amp;&amp; (pos[i][y+1] == pos[i][y] + 1)) ++y;\t\t\t\t\t\tmnc = min(mnc, 1LL * (n - (y-x+1)) * i) ;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t\tmc = min(mc, mnc);\t\t\tpos[i].clear();\t\t}\t\tcout &lt;&lt; mc &lt;&lt; '\\n';\t}\treturn 0;}\n\nD翻译有  个小组要上  节课，，每个小组的第  节课都不能占据相同的教室。有  个教室，每个教室由楼层和门牌号组成，具体来说，第  个门牌号是一个数 ，而其所在的楼层  满足 ，一个教室的索引值 ，保证每个教室的  不同，且 。若某小组相邻的两节课所在的教室楼层不同，则会付出等同于这两个楼层差的绝对值的代价。请你为这  个小组规划教室，最大化代价。 组数据。。\n题解容易发现对于任意一个小组，其上课的楼层按顺序一定是 ，因此问题被我们简化为了只有两节课的情况。\n将楼层排序，不妨设 ，设第  个小组第一节课在  教室，第二节课在  教室。总代价即为 。\n容易发现，如果某个 ，则我们一定尽量将其往前。反之则将其往后。对于  也同理。因此， 与  均为靠头尾的两段连续段且长度有关联。不妨  的头部长度为 ，尾部长度为 ，易知  的头部长度为 ，尾部长度为 。则代价即为 ，易知  时代价取最大值。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;int n, m, a[100005];int main() {\tint t = rd(); while(t--) {\t\tn = rd(); m = rd(); f(i,1,m) a[i] = rd() ;\t\tsort(a+1, a+m+1) ;\t\tint ans = 0; int o = (n&amp;1), tn = n - o;\t\tf(i,1,(tn&gt;&gt;1)) {\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[m-i+1]) : (a[i]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[i]) : (a[m-i+1]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t}\t\tif(o) {\t\t\tint i = (tn&gt;&gt;1) + 1;\t\t\tf(t,0,5) cout &lt;&lt; ( (t&amp;1) ? (a[m-i+1]) : (a[i]) ) &lt;&lt; ' ';\t\t\tans += 5 * ((a[m-i+1] / 100) - (a[i] / 100)) ;\t\t\tcout &lt;&lt; '\\n' ;\t\t}\t\tcerr &lt;&lt; ans &lt;&lt; '\\n';\t}\treturn 0;}// n group// m classroom// 1 group ~ 6 class\n\nE翻译给定一个长度为 ，由  组成的字符串，有  次操作，每次操作给定两个字符 ，代表可以将字符串中的一个字符  改为 。现在按顺序依次执行这  次操作（每次操作也可以选择不执行），最小化操作完成后字符串的字段序。 组数据。。\n题解考虑对于每个位置上的字符的操作，仅有可能为以下几种：\n\nP: \nQ: \nR: \nS: \nT: \n\n容易发现我们只需要贪心的，从前往后对于每个位置尽可能最小化该位置的最终字符，即可得到最小字典序。问题出在 P, T 操作之间对于  操作的争抢。我们可能会考虑到，如果对于某个位置 A 实施了 T 操作，会不会导致  减少（而如果换成 S 操作则不会减少），从而使得后面的位置 B 无法利用 P 操作了呢？事实上这是无需担忧的，我们不妨考虑这种矛盾出现的情况，用 S 操作替换 T 操作的前提是我们可以先在 A 位置实施 S 操作，再在 B 位置实施 P 操作，这就意味着我们有 , , ,  操作各一个，我们完全可以在 A 位置实施 T 操作而在 B 位置实施 Q 操作，一定不劣。\n因此，对于每个位置，我们贪心的优先按照 Q &gt; P, T &gt; S &gt; R 的顺序尽可能执行操作即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;string str; int n, q;set&lt;int&gt; B, D; vector&lt;int&gt; A, C; int posA, posC, bdC, bdA;void _try(int pos) {\tif(str[pos] == 'a') return ;\tif(str[pos] == 'b') {\t\tif(B.size()) B.erase(B.begin()), str[pos] = 'a';\t\telse if(posA &lt; bdA) {\t\t\tauto it = D.lower_bound(A[posA]);\t\t\tif(it != D.end()) ++posA, D.erase(it), str[pos] = 'a';\t\t}\t}\tif(str[pos] == 'c') {\t\tif(D.size()) D.erase(D.begin()), str[pos] = 'a';\t\telse if(posC &lt; bdC){\t\t\tauto it = B.lower_bound(C[posC]);\t\t\tif(it != B.end()) ++posC, B.erase(it), str[pos] = 'a';\t\t}\t\tif(str[pos] == 'c' &amp;&amp; posC &lt; bdC) --bdC, str[pos] = 'b';\t}}void solve() {\tcin &gt;&gt; n &gt;&gt; q &gt;&gt; str;\tf(i,1,q) {\t\tchar x, y; cin &gt;&gt; x &gt;&gt; y;\t\tif(x == 'b' &amp;&amp; y == 'c') A.pb(i), ++bdA;\t\tif(x == 'b' &amp;&amp; y == 'a') B.insert(i);\t\tif(x == 'c' &amp;&amp; y == 'b') C.pb(i), ++bdC;\t\tif(x == 'c' &amp;&amp; y == 'a') D.insert(i);\t}\tf(i,0,n-1) _try(i);\tcout &lt;&lt; str &lt;&lt; '\\n' ;\tposA = posC = bdC = bdA = 0; A.clear(); C.clear(); B.clear(); D.clear();}int main() {\tios :: sync_with_stdio(false); cin.tie(0); cout.tie(0);\tint t; cin &gt;&gt; t; while(t--) solve();\treturn 0;}/*operationA:(b, c) B(b, a) C(c, b) D(c, a)b-&gt;a: B, ADc-&gt;b: Cc-&gt;a: D, CB*/\n\nF翻译给定一张网格纸，构造一个四连通块，使得其周长与面积的比值等于 ，无解输出 。 组数据。任一构造使用的连通块面积不得超过 。\n\n题解不妨设现有一个连通块面积为 ，周长为 。若新增一个方格，则  增加 ，而  增加  或 。初始状态下，。\n设  增加  的次数为 , 增加  的次数为 ，则所有可能的  均应能写成  的形式。不难发现，若 ，则必有 ，若 ，则必有 。对应的构造是容易的。至此， 的问题已经处理完成。\n接下来考虑  的情况。容易发现我们只需要解如下不定方程组：\n$$\\begin{align}\n\n\\end{align}$$\n容易发现该方程组一定有满足题目要求的解。简单枚举  即可。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;void solve() {\tint p = rd(), s = rd();\tif(p &gt;= 2 * s) {\t\tint res = p - 2*s;\t\tif(res == 0) { cout &lt;&lt; \"4\\n0 0\\n0 1\\n1 0\\n1 1\\n\" ; return ; }\t\tif((2*s) % res != 0) { cout &lt;&lt; \"-1\" &lt;&lt; '\\n'; return ; }\t\tint x = (2*s) / res;\t\tcout &lt;&lt; x &lt;&lt; '\\n' ;\t\tf(i,1,x) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n' ;\t} else {\t\tif(p%2) p*=2, s*=2 ;\t\tfor(int k = 1; ; ++k) {\t\t\tint Rp = p * k, Rs = s * k, v = (Rp - 4) / 2, a = v/2, b = v-(v/2);\t\t\tif((Rs &lt;= (a+1) * (b+1)) &amp;&amp; (Rs &gt;= a + b + 1)) {\t\t\t\tcout &lt;&lt; Rs &lt;&lt; '\\n' ;\t\t\t\tint x = Rs - (a + b + 1) ;\t\t\t\tf(i,1,a+1) f(j,1,b+1) {\t\t\t\t\tif((i == 1) || (j == 1)) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n' ;\t\t\t\t\telse if(x) { --x; cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n'; }\t\t\t\t}\t\t\t\treturn ;\t\t\t}\t\t}\t}}int main() {\tint t=rd(); while(t--) solve();\treturn 0;}\n\nG翻译对于一个长度为  的序列，定义它是好的当且仅当它能被划分为前后两段，且前段中的所有数均大于后段中的所有数，或者后段中的所有数均大于前段中的所有数。\n给定一个长度为  的排列 ， 次询问该排列中  之间的子段是否是好的。强制在线。（采用交互实现，具体参照原题）\n题解考虑若一个子段  是好的，必然存在一个 ，使得可以将这一子段划分为前后两段，且满足以下两个条件之一：\n\n前段的所有数均不大于 ，后段的所有数均大于 。\n\n前段的所有数均不小于 ，后段的所有数均小于 。\n\n\n考虑逐渐令  增大来回答每个询问。记 。维护  的所有连续 01 段。容易发现这些 01 段只会发生  次变化，易于使用 std::set&lt; tuple&lt;int, int, int&gt; &gt; 维护。考虑相邻的两个连续 01 段，假设第一个连续段覆盖 ，第二个连续段覆盖 ，则对于所有  的 ，这些字段都是好的。\n预处理出所有这样的三元组 ，易知这些三元组的数量是  的。对于每个三元组按照  使用主席树维护即可。具体来说，每个  在  处令  增加 1，在  处撤销这一修改。使用差分优化即可避免区间修改。\n#include&lt;bits/stdc++.h&gt;#define f(i,x,y) for(int i=x, i##end=y; i&lt;=i##end; ++i)#define d(i,x,y) for(int i=y, i##end=x; i&gt;=i##end; --i)#define uf(i,x,y) for(int i=x, i##end=y; i&lt;i##end; ++i)#define ll long long#define pir pair&lt;int, int&gt;#define fir first#define sec second#define mp make_pair#define pb push_back char ch;int rd() {\tint f=1, x=0; ch=getchar();\twhile(!isdigit(ch)) { f=((ch=='-')?-1:f); ch=getchar(); }\twhile(isdigit(ch)) { x=x*10+ch-'0'; ch=getchar(); }\treturn x*f;}void rd(int&amp; x) { x=rd(); }using namespace std;const int _ = 32e5 + 5, __ = 32e5 + 5;int n, p[_], pos[_], q, x[_];set&lt; tuple&lt;int, int, int&gt; &gt; blocks ;// x[i] = (p[i] &lt;= t) ? 1 : 0;// (r, l, v) i in [l, r], x[i] = vset&lt; tuple&lt;int, int, int&gt; &gt; tmp_ok;tuple&lt;int, int, int&gt; ok[__]; int tot;void updL(set&lt; tuple&lt;int, int, int&gt; &gt; :: iterator it) {\tauto itL = it; --itL;\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*itL); tie(r2, l2, v2) = (*it);\tassert(l2 == r + 1);\ttmp_ok.insert(make_tuple(l, r, r2)) ;\t// (l, m, r)\t// [L, R] is ok when l &lt;= L &lt;= m &lt; r &lt;= r2}void updR(set&lt; tuple&lt;int, int, int&gt; &gt; :: iterator it) {\tauto itR = it; ++itR;\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*it); tie(r2, l2, v2) = (*itR);\tassert(l2 == r + 1);\ttmp_ok.insert(make_tuple(l, r, r2)) ;\t// (l, m, r)\t// [L, R] is ok when l &lt;= L &lt;= m &lt; r &lt;= r2}void upd(int r) {\tauto it = blocks.lower_bound(make_tuple(r, 0, 0)) ;\tif(it != blocks.begin()) updL(it);\tif(it != --blocks.end()) updR(it);}void alter(int p) {\tx[p] = 1; // cerr &lt;&lt; \"Handle : \" &lt;&lt; p &lt;&lt; endl;\tif(p==1) {\t\tif(x[p+1] == 1) {\t\t\tblocks.erase(blocks.begin()) ;\t\t\tauto it = blocks.begin(); int l, r, v; tie(r, l, v) = (*it); assert(v == 1);\t\t\tblocks.erase(it); blocks.insert(make_tuple(r, l-1, v)) ; upd(r);\t\t} else {\t\t\tauto it = blocks.begin(); int l, r, v; tie(r, l, v) = (*it); assert(v == 0);\t\t\tblocks.erase(blocks.begin()) ;\t\t\tblocks.insert(make_tuple(1, 1, 1)) ; blocks.insert(make_tuple(r, l+1, v)) ;\t\t\tupd(1); upd(r);\t\t}\t\treturn ;\t}\tif(p==n) {\t\tif(x[p-1] == 1) {\t\t\tblocks.erase(--blocks.end()) ;\t\t\tauto it = --blocks.end(); int l, r, v; tie(r, l, v) = (*it); assert(v == 1);\t\t\tblocks.erase(it); blocks.insert(make_tuple(r+1, l, v)) ; upd(r+1);\t\t} else {\t\t\tauto it = --blocks.end(); int l, r, v; tie(r, l, v) = (*it); assert(v == 0);\t\t\tblocks.erase(it); blocks.insert(make_tuple(n, n, 1)); blocks.insert(make_tuple(r-1, l, v)) ;\t\t\tupd(n); upd(r-1);\t\t}\t\treturn ;\t}\tint Lv = x[p-1], Rv = x[p+1], t = (Lv&lt;&lt;1) + Rv;\tif(t==0) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); assert(it != blocks.end()); int l, r, v; tie(r, l, v) = (*it); /*cerr &lt;&lt; \"[\" &lt;&lt; l &lt;&lt; \", \" &lt;&lt; r &lt;&lt; \", \" &lt;&lt; v &lt;&lt; \"]\" &lt;&lt; endl;*/ assert(v == 0);\t\tblocks.erase(it); blocks.insert(make_tuple(p-1, l, 0)); blocks.insert(make_tuple(r, p+1, 0)); blocks.insert(make_tuple(p, p, 1));\t\tupd(p-1); upd(p); upd(r);\t}\tif(t==1) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); int l, r, v; tie(r, l, v) = (*it); assert(v == 0); assert(r == p);\t\tauto it2 = it; ++it2; int l2, r2, v2; tie(r2, l2, v2) = (*it2); assert(v2 == 1);\t\tblocks.erase(it); blocks.erase(it2); blocks.insert(make_tuple(r-1, l, 0)); blocks.insert(make_tuple(r2, l2-1, 1));\t\tupd(r-1); upd(r2);\t}\tif(t==2) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)); int l, r, v; tie(r, l, v) = (*it); assert(v == 0); assert(l == p);\t\tauto it2 = it; --it2; int l2, r2, v2; tie(r2, l2, v2) = (*it2); assert(v2 == 1);\t\tblocks.erase(it); blocks.erase(it2); blocks.insert(make_tuple(r2+1, l2, 1)); blocks.insert(make_tuple(r, l+1, 0));\t\tupd(r2+1); upd(r);\t}\tif(t==3) {\t\tauto it = blocks.lower_bound(make_tuple(p, 0, 0)), itL = it, itR = it; --itL; ++itR;\t\tint l, l2, r, r2, v, v2; tie(r, l, v) = (*itL); tie(r2, l2, v2) = (*itR); assert(v2 == 1); assert(v2 == 1); assert(r == p-1); assert(l2 = p+1);\t\tblocks.erase(it); blocks.erase(itL); blocks.erase(itR); blocks.insert(make_tuple(r2, l, 1));\t\tupd(r2);\t}}int sum[__ * 20], rt[__ &lt;&lt; 1], ls[__ * 20], rs[__ * 20], tott;void pushup(int p) {\tsum[p] = sum[ls[p]] + sum[rs[p]] ;}void modify(int o, int&amp; p, int l, int r, int q, int x) {\tif(q&gt;r) {\t\tp=++tott; ls[p] = ls[o]; rs[p] = rs[o]; sum[p] = sum[o]; return ;\t}\tif(!p) p = ++tott, sum[p] = sum[o];\tif(l==r) { sum[p] = sum[p] + x; return ; }\tint mid=(l+r)&gt;&gt;1;\tif(q&lt;=mid) rs[p] = rs[o], modify(ls[o], ls[p], l, mid, q, x);\telse ls[p] = ls[o], modify(rs[o], rs[p], mid+1, r, q, x);\tpushup(p);}int query(int p, int l, int r, int ql, int qr) {\tif(l &gt; qr || r &lt; ql) return 0;\tif(ql &lt;= l &amp;&amp; r &lt;= qr) return sum[p];\tint mid = (l+r&gt;&gt;1), resL = 0, resR = 0;\tif(ql &lt;= mid) resL = query(ls[p], l, mid, ql, qr);\tif(qr &gt; mid) resR = query(rs[p], mid+1, r, ql, qr);\treturn resL + resR ;}pair&lt; pir, pir &gt; mods[__ &lt;&lt; 1] ; int totc, rtL[_];int main() {\trd(n); f(i,1,n) rd(p[i]), pos[p[i]] = i; blocks.insert(make_tuple(n, 1, 0)); f(i,1,n) alter(pos[i]);\tfor(auto v : tmp_ok) ok[++tot] = v;\tcerr &lt;&lt; tot &lt;&lt; endl;\tf(i,1,tot) {\t\tint l, m, r; tie(l, m, r) = ::ok[i];\t\tmods[++totc] = mp(mp(l, m+1), mp(r, 1));\t\tmods[++totc] = mp(mp(m+1, m+1), mp(r, -1));\t}\tf(i,1,n) mods[++totc] = mp(mp(i, 1), mp(n, 0));\tsort(mods+1, mods+totc+1);\tf(i,1,totc) {\t\tint tl=mods[i].fir.fir, l=mods[i].fir.sec, r=mods[i].sec.fir, x=mods[i].sec.sec;\t\tmodify(rt[2*i-2], rt[2*i-1], 1, n, l, x);\t\tmodify(rt[2*i-1], rt[2*i], 1, n, r+1, -x);\t}\tint p = 0;\tf(i,1,n) {\t\twhile(p+1 &lt;= totc &amp;&amp; mods[p+1].fir.fir &lt;= i) ++p;\t\trtL[i] = rt[2*p];\t}\trd(q); f(i,1,q) {\t\tint L = rd(), R = rd(), ok = 0;\t\t// f(x,1,tot) {\t\t\t// int l, m, r; tie(l, m, r) = ::ok[x];\t\t\t// [L, R] is ok when l &lt;= L &lt;= m &lt; R &lt;= r\t\t\t// if((l &lt;= L) &amp;&amp; (L &lt;= m) &amp;&amp; (m &lt; R) &amp;&amp; (R &lt;= r)) ok = 1;\t\t// }\t\tok = query(rtL[L], 1, n, 1, R);\t\t// cerr &lt;&lt; ok &lt;&lt; endl;\t\tcout &lt;&lt; ( (ok&gt;0) ? \"YES\" : \"NO\" ) &lt;&lt; '\\n';\t\tif(!(i%10)) cout.flush();\t}\t\treturn 0;}"},{"title":"暑假日记","url":"/%E6%9A%91%E5%81%87%E6%97%A5%E8%AE%B0/","content":"\n\n\n暑期日记项目\n七月\n7.14\n早上\n下午\n晚上\n\n\n7.15\n早上\n\n\n\n\n\n\n\n\n\n暑期日记项目时光在冗杂中飞逝，转瞬之间这个“人生中最长的暑假”已经行至正中。回望过去的一个半月，惊叹于自己所做事情至少，懊悔于自己之怠惰。\n是而建此项目，所望唯监督自己，所以能奋发图强，增益不能。\n所记或颇为琐碎，大抵流水账尔。然而所以记之者，不过待后观之而一笑尔。\n七月7.14早上\n搭建 github pages 与本地的 hexo 环境，更换 arknights 主题，搭建 Gitalk。发布暑假日记博客。\n\n拿日语书快递\n\n\n下午\n看视频\n\n睡觉\n\n\n晚上\n去了趟大士院吃了点南昌特色，然后在八一广场逛了一圈\n\n看视频\n\n\n话说感觉最近看视频有点多了，要不从明天开始每看一个视频就写一个总结&amp;观后感丢这里？\n明天开始更新一下每天的饭（？\n7.15早上\n早饭-6.5r\n\n\n早饭-6.5r\n\n\n\n写 CF2111 总结\n\n开始 CF2119\n\n\n","categories":["暑假日记"],"tags":["记录","工程","生活","ACM"]}]